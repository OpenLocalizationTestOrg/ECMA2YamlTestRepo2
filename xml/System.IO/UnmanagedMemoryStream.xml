<Type Name="UnmanagedMemoryStream" FullName="System.IO.UnmanagedMemoryStream">
  <TypeSignature Language="C#" Value="public class UnmanagedMemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UnmanagedMemoryStream extends System.IO.Stream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides access to unmanaged blocks of memory from managed code.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This class supports access to unmanaged memory using the existing stream-based model and does not require that the contents in the unmanaged memory be copied to the heap.  
  
> [!IMPORTANT]
>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the UnmanagedMemoryStream class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/t-system.io.unmanagedmem_1.cs)]  
  
 ]]></format>
    </remarks>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnmanagedMemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the required permission.</exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">for accessing unmanaged memory.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="pointer">A pointer to an unmanaged memory location.</param>
        <param name="length">The length of the memory to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location and memory length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This constructor creates a new instance of the <xref:System.IO.UnmanagedMemoryStream> class, and by default sets the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property to `false` and the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property to `true`. The <xref:System.IO.UnmanagedMemoryStream.Length%2A> property is set to the value of the `length` parameter and cannot be changed.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_4_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the required permission.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="pointer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="length" /> value is less than zero.  
  
 \- or -  
  
 The <paramref name="length" /> is large enough to cause an overflow.</exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">for accessing unmanaged memory.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to contain the unmanaged memory stream.</param>
        <param name="offset">The byte position in the buffer at which to start the unmanaged memory stream.</param>
        <param name="length">The length of the unmanaged memory stream.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset and length.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer">A pointer to an unmanaged memory location.</param>
        <param name="length">The length of the memory to use.</param>
        <param name="capacity">The total amount of memory assigned to the stream.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location, memory length, total amount of memory, and file access values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `length` parameter defines the current amount of memory in use. If reading or appending data to the stream, the `length` value should be equal to the amount of valid data in the stream to be read from or preserved. If writing to the stream, this value should be zero.  
  
 The `capacity` parameter indicates the amount of total memory available. This value can describe a region that is longer than the length specified, or indicate a region that can be appended to. Any attempt to write beyond this value will fail.  
  
 The `access` parameter sets the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, and <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> properties. Note that specifying <xref:System.IO.FileAccess> does not guarantee that the stream will be writable. The access parameters allow the implementer to create an object whose implementation can match the actual stream that is exposed.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/62930bcb-5dff-4d38-8341-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the required permission.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="pointer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="length" /> value is less than zero.  
  
 \- or -  
  
 The <paramref name="capacity" /> value is less than zero.  
  
 \- or -  
  
 The <paramref name="length" /> value is greater than the <paramref name="capacity" /> value.</exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">for accessing unmanaged memory.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to contain the unmanaged memory stream.</param>
        <param name="offset">The byte position in the buffer at which to start the unmanaged memory stream.</param>
        <param name="length">The length of the unmanaged memory stream.</param>
        <param name="access">The mode of file access to the unmanaged memory stream.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a stream supports reading.</summary>
        <value>
          <see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter that did not include reading the stream and if the stream is closed; otherwise, <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property indicates whether the current stream object supports reading.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanRead property before attempting to display the contents to the console.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_2_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a stream supports seeking.</summary>
        <value>
          <see langword="false" /> if the stream is closed; otherwise, <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property indicates whether the current stream object supports seeking.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a stream supports writing.</summary>
        <value>
          <see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter value that supports writing or was created by a constructor that had no parameters, or if the stream is closed; otherwise, <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property indicates whether the current stream object supports writing.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanWrite property before attempting to write the data to the stream.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public long Capacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</summary>
        <value>The size or capacity of the stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property returns the `capacity` value provided to the constructor. If no `capacity` value was specified when the stream was initialized, this property returns the stream length.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.UnmanagedMemoryStream" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method. <xref:System.ComponentModel.Component.Dispose%2A> invokes the protected Dispose method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes Dispose with `disposing` set to `false`.  
  
 When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.UnmanagedMemoryStream> references. This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Overrides the &lt;xref:System.IO.Stream.Flush%2A&gt; method so that no action is performed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs no action for this class but is included as part of the <xref:System.IO.Stream> base class. Since any data is written to RAM, this method is redundant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is &lt;xref:System.Threading.CancellationToken.None%2A&gt;.</param>
        <summary>Overrides the &lt;xref:System.IO.Stream.FlushAsync%2A?displayProperty=fullName&gt; method so that the operation is cancelled if specified, but no other action is performed.  
  
 Available starting in [!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]</summary>
        <returns>A task that represents the asynchronous flush operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the operation isn’t cancelled, the <xref:System.IO.UnmanagedMemoryStream> calls the <xref:System.IO.UnmanagedMemoryStream.Flush%2A> method, which means that no action performed.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer">A pointer to an unmanaged memory location.</param>
        <param name="length">The length of the memory to use.</param>
        <param name="capacity">The total amount of memory assigned to the stream.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class by using a pointer to an unmanaged memory location.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is equivalent to the <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructor. It supports methods that need to initialize the pointer before setting stream variables and, therefore, cannot call the parameterized constructor. Such methods should use the default constructor, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialize the pointer, and then invoke the Initialize method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the required permission.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="pointer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="length" /> value is less than zero.  
  
 \- or -  
  
 The <paramref name="capacity" /> value is less than zero.  
  
 \- or -  
  
 The <paramref name="length" /> value is large enough to cause an overflow.</exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">for accessing unmanaged memory.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to contain the unmanaged memory stream.</param>
        <param name="offset">The byte position in the buffer at which to start the unmanaged memory stream.</param>
        <param name="length">The length of the unmanaged memory stream.</param>
        <param name="access">The mode of file access to the unmanaged memory stream.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of the data in a stream.</summary>
        <value>The length of the data in the stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If unchanged since the stream was initialized, this property returns the length value provided to the constructor. If changes to the stream have occurred, this property reflects any changes to the length of the data.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position in a stream.</summary>
        <value>The current position in the stream.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When a stream is initialized, this property is set to zero.  
  
 Although you can set the position of the stream beyond the stream's capacity, you will not be able to access that area using the <xref:System.IO.UnmanagedMemoryStream.Read%2A> and <xref:System.IO.UnmanagedMemoryStream.Write%2A> methods. <xref:System.IO.UnmanagedMemoryStream.Read%2A> will return 0 and <xref:System.IO.UnmanagedMemoryStream.Write%2A> will throw a <xref:System.NotSupportedException>. This support is primarily for design and code compatibility with basic stream operations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The position is set to a value that is less than zero, or the position is larger than &lt;xref:System.Int32.MaxValue&gt; or results in overflow when added to the current pointer.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="PositionPointer">
      <MemberSignature Language="C#" Value="public byte* PositionPointer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8* PositionPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte*</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a byte pointer to a stream based on the current position in the stream.</summary>
        <value>A byte pointer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To return a pointer to the entire stream, set the <xref:System.IO.UnmanagedMemoryStream.Position%2A> property to zero, and then call this property.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">The current position is larger than the capacity of the stream.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The position is being set is not a valid position in the current stream.</exception>
        <exception cref="T:System.IO.IOException">The pointer is being set to a lower value than the starting position of the stream.</exception>
        <exception cref="T:System.NotSupportedException">The stream was initialized for use with a &lt;xref:System.Runtime.InteropServices.SafeBuffer&gt;. The PositionPointer property is valid only for streams that are initialized with a &lt;xref:System.Byte&gt; pointer.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code, such as calling native code with platform invoke or COM integration. Security action: <see cref="T:System.Security.Permissions.SecurityAction" />. Associated enumeration: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">When this method returns, contains the specified byte array with the values between `offset` and (`offset` + `count` - 1) replaced by the bytes read from the current source. This parameter is passed uninitialized.</param>
        <param name="offset">The zero-based byte offset in `buffer` at which to begin storing the data read from the current stream.</param>
        <param name="count">The maximum number of bytes to read from the current stream.</param>
        <summary>Reads the specified number of bytes into the specified array.</summary>
        <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `offset` parameter gives the offset of the byte in the `array` parameter (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream. The returned value is the actual number of bytes read, or zero if the end of the stream is reached. If the read operation is successful, the current position of the stream is advanced by the number of bytes read. If an exception occurs, the current position of the stream is unchanged.  
  
 The Read method returns zero only after reaching the end of the stream. Otherwise, Read always reads at least one byte from the stream before returning. If no data is available from the stream upon a call to Read, the method will block until at least one byte of data can be returned. An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_2_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying memory does not support reading.  
  
 \- or -  
  
 The &lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt; property is set to <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than zero.  
  
 \- or -  
  
 The <paramref name="count" /> parameter is less than zero.</exception>
        <exception cref="T:System.ArgumentException">The length of the buffer array minus the <paramref name="offset" /> parameter is less than the <paramref name="count" /> parameter.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to write the data into.</param>
        <param name="offset">The byte offset in `buffer` at which to begin writing data from the stream.</param>
        <param name="count">The maximum number of bytes to read.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is &lt;xref:System.Threading.CancellationToken.None%2A&gt;.</param>
        <summary>Asynchronously reads the specified number of bytes into the specified array.  
  
 Available starting in [!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]</summary>
        <returns>A task that represents the asynchronous read operation. The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If an exception occurs during the read operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName> of the property of the returned task.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</summary>
        <returns>The unsigned byte cast to an &lt;xref:System.Int32&gt; object, or -1 if at the end of the stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to return integer values from the stream.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying memory does not support reading.  
  
 \- or -  
  
 The current position is at the end of the stream.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">The point relative to `origin` to begin seeking from.</param>
        <param name="loc">Specifies the beginning, the end, or the current position as a reference point for `origin`, using a value of type &lt;xref:System.IO.SeekOrigin&gt;.</param>
        <summary>Sets the current position of the current stream to the given value.</summary>
        <returns>The new position in the stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For more information about seeking, see <xref:System.IO.FileStream.Seek%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An attempt was made to seek before the beginning of the stream.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> value is larger than the maximum size of the stream.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="loc" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The length of the stream.</param>
        <summary>Sets the length of a stream to a specified value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the given value is less than the current length of the stream, the stream is truncated. If the given value is larger than the current length of the stream, the stream is expanded. If the stream is expanded, the contents of the stream between the old and the new lengths are undefined.  
  
 A stream must support both writing and seeking for SetLength to work.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error has occurred.</exception>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying memory does not support writing.  
  
 \- or -  
  
 An attempt is made to write to the stream and the &lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt; property is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The specified <paramref name="value" /> exceeds the capacity of the stream.  
  
 \- or -  
  
 The specified <paramref name="value" /> is negative.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The byte array from which to copy bytes to the current stream.</param>
        <param name="offset">The offset in the buffer at which to begin copying bytes to the current stream.</param>
        <param name="count">The number of bytes to write to the current stream.</param>
        <summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Writing occurs at the current position in the stream.  
  
   
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_3_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying memory does not support writing.  
  
 \- or -  
  
 An attempt is made to write to the stream and the &lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt; property is <see langword="false" />.  
  
 \- or -  
  
 The <paramref name="count" /> value is greater than the capacity of the stream.  
  
 \- or -  
  
 The position is at the end of the stream capacity.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">One of the specified parameters is less than zero.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="offset" /> parameter minus the length of the <paramref name="buffer" /> parameter is less than the <paramref name="count" /> parameter.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to write data from.</param>
        <param name="offset">The zero-based byte offset in `buffer` from which to begin copying bytes to the stream.</param>
        <param name="count">The maximum number of bytes to write.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is &lt;xref:System.Threading.CancellationToken.None%2A&gt;.</param>
        <summary>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.  
  
 Available starting in [!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If an exception occurs during the write operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName> of the property of the returned task.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">A byte value written to the stream.</param>
        <summary>Writes a byte to the current position in the file stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.  
  
 [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying memory does not support writing.  
  
 \- or -  
  
 An attempt is made to write to the stream and the &lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt; property is <see langword="false" />.  
  
 \- or -  
  
 The current position is at the end of the capacity of the stream.</exception>
        <exception cref="T:System.IO.IOException">The supplied <paramref name="value" /> causes the stream exceed its maximum capacity.</exception>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>