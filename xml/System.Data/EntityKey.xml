<Type Name="EntityKey" FullName="System.Data.EntityKey">
  <TypeSignature Language="C#" Value="public sealed class EntityKey : IEquatable&lt;System.Data.EntityKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityKey extends System.Object implements class System.IEquatable`1&lt;class System.Data.EntityKey&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Data.EntityKey&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract(IsReference=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides a durable reference to an object that is an instance of an entity type.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The EntityKey objects are immutable; that is, after they are constructed they cannot be modified.  
  
 For more information, see [Working with Entity Keys](http://msdn.microsoft.com/en-us/fe3f4206-d277-43a1-a72f-4e86fdf12b9f).  
  
   
  
## Examples  
 These examples are based on the [AdventureWorks Sales Model](http://msdn.microsoft.com/en-us/f16cd988-673f-4376-b034-129ca93c7832). The examples show you how to create and use an EntityKey.  
  
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/add/codesnippet/visualbasic/objectservicesconceptsvb/Source.vb#entitykeyclass_trygetobjectbykey)]
 [!code-cs[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/add/codesnippet/csharp/objectservicesconceptscs/Source.cs#entitykeyclass_trygetobjectbykey)]  
  
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/add/codesnippet/visualbasic/objectservicesconceptsvb/Source.vb#addobjectusingkey)]
 [!code-cs[DP ObjectServices Concepts#AddObjectUsingKey](~/add/codesnippet/csharp/objectservicesconceptscs/Source.cs#addobjectusingkey)]  
  
 ]]></format>
    </remarks>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; entityKeyValues) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A &lt;xref:System.String&gt; that is the entity set name qualified by the entity container name.</param>
        <param name="entityKeyValues">A generic &lt;xref:System.Collections.Generic.KeyValuePair&gt; collection.  
  
 Each key/value pair has a property name as the key and the value of that property as the value. There should be one pair for each property that is part of the <see cref="T:System.Data.EntityKey" />. The order of the key/value pairs is not important, but each key property should be included. The property names are simple names that are not qualified with an entity type name or the schema name.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and a generic &lt;xref:System.Collections.Generic.KeyValuePair&gt; collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 This example is based on the [AdventureWorks Sales Model](http://msdn.microsoft.com/en-us/f16cd988-673f-4376-b034-129ca93c7832). The example shows you how to create and use an <xref:System.Data.EntityKey>.  
  
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/add/codesnippet/visualbasic/objectservicesconceptsvb/Source.vb#addobjectusingkey)]
 [!code-cs[DP ObjectServices Concepts#AddObjectUsingKey](~/add/codesnippet/csharp/objectservicesconceptscs/Source.cs#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.EntityKeyMember&gt; entityKeyValues) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A &lt;xref:System.String&gt; that is the entity set name qualified by the entity container name.</param>
        <param name="entityKeyValues">An &lt;xref:System.Collections.Generic.IEnumerable%601&gt; collection of <see cref="T:System.Data.EntityKeyMember" /> objects with which to initialize the key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and an &lt;xref:System.Collections.Generic.IEnumerable%601&gt; collection of <see cref="T:System.Data.EntityKeyMember" /> objects.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, string keyName, object keyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, string keyName, object keyValue) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="keyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A &lt;xref:System.String&gt; that is the entity set name qualified by the entity container name.</param>
        <param name="keyName">A &lt;xref:System.String&gt; that is the name of the key.</param>
        <param name="keyValue">An &lt;xref:System.Object&gt; that is the key value.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and specific entity key pair.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 This example is based on the [AdventureWorks Sales Model](http://msdn.microsoft.com/en-us/f16cd988-673f-4376-b034-129ca93c7832). The example shows you how to create and use an <xref:System.Data.EntityKey>.  
  
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/add/codesnippet/visualbasic/objectservicesconceptsvb/Source.vb#addobjectusingkey)]
 [!code-cs[DP ObjectServices Concepts#AddObjectUsingKey](~/add/codesnippet/csharp/objectservicesconceptscs/Source.cs#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EntityContainerName">
      <MemberSignature Language="C#" Value="public string EntityContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntityContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the entity container.</summary>
        <value>A &lt;xref:System.String&gt; value that is the name of the entity container for the entity to which the <see cref="T:System.Data.EntityKey" /> belongs.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EntityKeyValues">
      <MemberSignature Language="C#" Value="public System.Data.EntityKeyMember[] EntityKeyValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.EntityKeyMember[] EntityKeyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.EntityKeyMember[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the key values associated with this <see cref="T:System.Data.EntityKey" />.</summary>
        <value>A &lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt; of key values for this <see cref="T:System.Data.EntityKey" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Data.EntityKey> class contains a copy of the values that make up the logical key that is specified for this type of entity.  
  
 The members of the <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> each have a property name and a value in a <xref:System.Collections.Generic.KeyValuePair%602>, where the key is the property name and the value is the actual value of that property on the object.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EntityNotValidKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey EntityNotValidKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey EntityNotValidKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A simple <see cref="T:System.Data.EntityKey" /> identifying an entity that resulted from a failed [TREAT](~/add/includes/ajax-current-ext-md.md) operation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 There are various ways to get an invalid entity. The most common scenario is when an [!INCLUDE[esql](~/add/includes/ajax-current-ext-md.md)] query uses the [TREAT](../Topic/TREAT%20\(Entity%20SQL\).md) operator to interpret an instance of a polymorphic type as a particular type, and the instance in question does not match. ([TREAT](../Topic/TREAT%20\(Entity%20SQL\).md) is similar to the C# `as` operator). In this case, the query returns an entity that is not valid, and the entity key of the resulting entity is set to EntityNotValidKey.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EntitySetName">
      <MemberSignature Language="C#" Value="public string EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntitySetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the entity set.</summary>
        <value>A &lt;xref:System.String&gt; value that is the name of the entity set for the entity to which the <see cref="T:System.Data.EntityKey" /> belongs.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Data.EntityKey other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Data.EntityKey other) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="other">An <see cref="T:System.Data.EntityKey" /> object to compare with this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified <see cref="T:System.Data.EntityKey" />.</summary>
        <returns>
          <see langword="true" /> if this instance and <paramref name="other" /> have equal values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporary keys have different comparison semantics than permanent keys:  
  
-   Temporary keys use reference equality. That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.  
  
-   Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>. That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.  
  
 In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An &lt;xref:System.Object&gt; to compare with this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if this instance and <paramref name="obj" /> have equal values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporary keys have different comparison semantics than permanent keys:  
  
-   Temporary keys use reference equality. That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.  
  
-   Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>. That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their <xref:System.Data.Metadata.Edm.EntitySet> objects are the same and their key values are equal.  
  
 In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetEntitySet">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySet (System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySet(class System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataWorkspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
      </Parameters>
      <Docs>
        <param name="metadataWorkspace">The metadata workspace that contains the entity.</param>
        <summary>Gets the entity set for this entity key from the given metadata workspace.</summary>
        <returns>The <see cref="T:System.Data.Metadata.Edm.EntitySet" /> for the entity key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The entity set is accessed based on the entity container name and entity set name of the key.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The entity set could not be located in the specified metadata workspace.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serves as a hash function for the current <see cref="T:System.Data.EntityKey" /> object. GetHashCode is suitable for hashing algorithms and data structures such as a hash table.</summary>
        <returns>A hash code for the current <see cref="T:System.Data.EntityKey" />.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.EntityKey" /> is temporary.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.Data.EntityKey" /> is temporary; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When a new entity is created, the [!INCLUDE[adonet_ef](~/add/includes/adonet-ef-md.md)] defines temporary key and sets the IsTemporary property to `true`. When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method, the [!INCLUDE[adonet_ef](~/add/includes/adonet-ef-md.md)] assigns a permanent key and sets the IsTemporary property to `false`.  
  
> [!NOTE]
>  Temporary keys are constructed automatically by the framework; they cannot be constructed directly by a user.  
  
 Temporary keys have different comparison semantics than permanent keys:  
  
-   Temporary keys use reference equality. That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.  
  
-   Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>. That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.  
  
 In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.  
  
 When the <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A> method is called on an entity's <xref:System.Data.Objects.ObjectStateEntry> and the entity transitions from the <xref:System.Data.EntityState> state to <xref:System.Data.EntityState> state, the [!INCLUDE[adonet_ef](~/add/includes/adonet-ef-md.md)] automatically computes a new permanent key for the entity and synchronizes all temporary key references.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="NoEntitySetKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey NoEntitySetKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey NoEntitySetKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A singleton <see cref="T:System.Data.EntityKey" /> by which a read-only entity is identified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A read-only entity identifies an entity that is valid in every way, except that it is not associated with an actual entity set. This can occur as part of the result of an [!INCLUDE[esql](~/add/includes/ajax-current-ext-md.md)] query that constructs and returns an entity instance specified within the text of the query (as opposed to an entity that was retrieved from a database table). An entity that does not have an entity set cannot be persisted to the database until it is associated with some entity set. Therefore, the object materializer will treat this kind of entity as if the <xref:System.Data.Objects.MergeOption> merge option was specified, regardless of the actual merge option that was specified. An entity object will be created, but its identity will not be resolved and it will not be added to the state manager as part of the materialization process.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialized">
      <MemberSignature Language="C#" Value="public void OnDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Describes the source and destination of a given serialized stream and provides an additional caller-defined context.</param>
        <summary>Helper method that is used to deserialize an <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OnDeserialized is used by Object Services when deserializing an <xref:System.Data.EntityKey>. For more information, see [Serializing Objects](http://msdn.microsoft.com/en-us/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="OnDeserializing">
      <MemberSignature Language="C#" Value="public void OnDeserializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.</param>
        <summary>Helper method that is used to deserialize an <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OnDeserializing is used by Object Services when deserializing an <xref:System.Data.EntityKey>. For more information, see [Serializing Objects](http://msdn.microsoft.com/en-us/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <summary>Compares two <see cref="T:System.Data.EntityKey" /> objects.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="key1" /> and <paramref name="key2" /> values are equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporary keys have different comparison semantics than permanent keys:  
  
-   Temporary keys use reference equality. That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.  
  
-   Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>. That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.  
  
 In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <summary>Compares two <see cref="T:System.Data.EntityKey" /> objects.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="key1" /> and <paramref name="key2" /> values are not equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporary keys have different comparison semantics than permanent keys:  
  
-   Temporary keys use reference equality. That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.  
  
-   Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>. That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.  
  
 In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but regular keys do.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>