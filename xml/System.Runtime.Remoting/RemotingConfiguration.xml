<Type Name="RemotingConfiguration" FullName="System.Runtime.Remoting.RemotingConfiguration">
  <TypeSignature Language="C#" Value="public static class RemotingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingConfiguration extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides various static methods for configuring the remoting infrastructure.</summary>
    <remarks>To be added.</remarks>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName="ApplicationId">
      <MemberSignature Language="C#" Value="public static string ApplicationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the ID of the currently executing application.</summary>
        <value>A &lt;xref:System.String&gt; that contains the ID of the currently executing application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The application ID is prepended to the URI of the objects created by the currently executing application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">For operating with infrastructure code. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of a remoting application.</summary>
        <value>The name of a remoting application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An application name can be set only once, either through the current property or through a configuration file. If an application is running inside a hosted environment, such as Internet Information Services (IIS), this value might have already been set (usually to the virtual directory). The current property will return `null` if the application name has not been set.  
  
   
  
## Examples  
 The following code example demonstrates the use of the ApplicationName property to indicate the name of the remoting application. For the full example code, see examples for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> and <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> methods.  
  
 [!code-cs[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/csharp/p-system.runtime.remotin_94_1.cs)]
 [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/cpp/p-system.runtime.remotin_94_1.cpp)]
 [!code-vb[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/visualbasic/p-system.runtime.remotin_94_1.vb)]  
  
 The following code example demonstrates how to access an object remoted from a named application.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/cpp/p-system.runtime.remotin_94_2.cpp)]
 [!code-cs[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/csharp/p-system.runtime.remotin_94_2.cs)]
 [!code-vb[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/visualbasic/p-system.runtime.remotin_94_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels. This exception is thrown only when setting the property value.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use System.Runtime.Remoting.RemotingConfiguration.Configure(string fileName, bool ensureSecurity) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the remoting configuration file. Can be <see langword="null" />.</param>
        <summary>Reads the configuration file and configures the remoting infrastructure. Configure is obsolete. Please use &lt;xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29&gt; instead.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Configure is obsolete. Please use <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29> instead.  
  
 Passing `null` as the `filename` parameter will cause default remoting initialization without requiring the existence of a configuration file.  
  
 For configuration file syntax, see [Remoting Settings Schema](http://msdn.microsoft.com/en-us/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).  
  
> [!NOTE]
>  Marshal-by-reference objects (MBRs) do not reside in memory forever. Instead, unless the type overrides <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName> to control its own lifetime policies, each MBR has a finite lifetime before the .NET Framework remoting system begins the process of deleting it and reclaiming the memory. For more information, see [Lifetime Leases](http://msdn.microsoft.com/en-us/c72d561c-1266-4c8b-b258-2c168c08da9a).  
  
   
  
## Examples  
 [!code-cs[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/csharp/m-system.runtime.remotin_8_1.cs)]
 [!code-vb[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_8_1.vb)]
 [!code-cpp[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/cpp/m-system.runtime.remotin_8_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename, bool ensureSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename, bool ensureSecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="ensureSecurity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the remoting configuration file. Can be <see langword="null" />.</param>
        <param name="ensureSecurity">If set to <see langword="true" /> security is required. If set to <see langword="false" />, security is not required but still may be used.</param>
        <summary>Reads the configuration file and configures the remoting infrastructure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Passing `null` as the `filename` parameter will cause default remoting initialization without requiring the existence of a configuration file. For more information about remoting and security see [Security in Remoting.](http://msdn.microsoft.com/en-us/9574262c-d4b1-41c5-8600-24ff147c0add)  
  
 For configuration file syntax, see [Remoting Settings Schema](http://msdn.microsoft.com/en-us/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e).  
  
> [!NOTE]
>  Marshal-by-reference objects (MBRs) do not reside in memory forever. Instead, unless the type overrides <xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName> to control its own lifetime policies, each MBR has a finite lifetime before the .NET Framework remoting system begins the process of deleting it and reclaiming the memory. For more information, see [Lifetime Leases](http://msdn.microsoft.com/en-us/c72d561c-1266-4c8b-b258-2c168c08da9a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsEnabled">
      <MemberSignature Language="C#" Value="public static bool CustomErrorsEnabled (bool isLocalRequest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CustomErrorsEnabled(bool isLocalRequest) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isLocalRequest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isLocalRequest">
          <see langword="true" /> to specify local callers; <see langword="false" /> to specify remote callers.</param>
        <summary>Indicates whether the server channels in this application domain return filtered or complete exception information to local or remote callers.</summary>
        <returns>
          <see langword="true" /> if only filtered exception information is returned to local or remote callers, as specified by the <paramref name="isLocalRequest" /> parameter; <see langword="false" /> if complete exception information is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Complete exception information includes the exact server exception and the server stack trace. Filtered information includes a standard remoting exception but no server stack trace.  
  
 The `CustomErrorsEnabled` method reflects configuration settings that were specified in the `mode` attribute of the `<customErrors>` element of the application configuration file. For more information about configuration options, see [&#91;\<topic://cpconconfiguration>&#93;](http://msdn.microsoft.com/en-us/92c0c097-d984-4315-835b-7490ecdf1097).  
  
 The following table shows the three server channel property values that specify which callers receive exception information and what type of information they receive.  
  
|Value|Description|  
|-----------|-----------------|  
|`off`|All callers receive complete exception information.|  
|`on`|All callers receive filtered exception information.|  
|`remoteOnly`|Local callers receive complete exception information; remote callers receive filtered exception information.|  
  
 The following table shows the interaction of the `isLocalRequest` parameter and the server channel property.  
  
|Value|isLocalRequest|Return value|Description|  
|-----------|--------------------|------------------|-----------------|  
|`on`|`true`|`true`|Local callers receive filtered exception information.|  
|`on`|`false`|`true`|Remote callers receive filtered exception information.|  
|`off`|`true`|`false`|Local callers receive complete exception information.|  
|`off`|`false`|`false`|Remote callers receive complete exception information.|  
|`remoteOnly`|`true`|`false`|Local callers receive complete exception information.|  
|`remoteOnly`|`false`|`true`|Remote callers receive filtered exception information.|  
  
 For information about using application configuration files to control the return of exception information to callers, see the `<customErrors>` element.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.CustomErrorsModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets value that indicates how custom errors are handled.</summary>
        <value>A member of the <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> enumeration that indicates how custom errors are handled.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of object types registered on the client as types that will be activated remotely.</summary>
        <returns>An array of object types registered on the client as types that will be activated remotely.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For a detailed description of client-activated objects, see [&#91;\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of object types registered on the service end that can be activated on request from a client.</summary>
        <returns>An array of object types registered on the service end that can be activated on request from a client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For a detailed description of client-activated objects, see [&#91;\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
   
  
## Examples  
 [!code-cs[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/csharp/131c20b0-ea6b-424e-a05f-_1.cs)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/visualbasic/131c20b0-ea6b-424e-a05f-_1.vb)]
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/cpp/131c20b0-ea6b-424e-a05f-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of object types registered on the client end as well-known types.</summary>
        <returns>An array of object types registered on the client end as well-known types.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Well-known object types can be either single call or singleton. If an object type is single call, then a new instance of it is created each time a call from the client comes in. All calls to a singleton object are handled by one instance of that object.  
  
 For a more detailed description of well-known objects, see [&#91;\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/visualbasic/90e2868e-717f-4977-8f71-_1.vb)]
 [!code-cs[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/csharp/90e2868e-717f-4977-8f71-_1.cs)]
 [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/cpp/90e2868e-717f-4977-8f71-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an array of object types registered on the service end as well-known types.</summary>
        <returns>An array of object types registered on the service end as well-known types.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Well-known object types can be either single call or singleton. If an object type is single call, then a new instance of it is created each time a call from the client comes in. All calls to a singleton object are handled by one instance of that object.  
  
 For a more detailed description of well-known objects, see [&#91;\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cs[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/csharp/86dd75a5-23bc-425c-9a34-_1.cs)]
 [!code-vb[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/visualbasic/86dd75a5-23bc-425c-9a34-_1.vb)]
 [!code-cpp[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/cpp/86dd75a5-23bc-425c-9a34-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsActivationAllowed">
      <MemberSignature Language="C#" Value="public static bool IsActivationAllowed (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsActivationAllowed(class System.Type svrType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">The object &lt;xref:System.Type&gt; to check.</param>
        <summary>Returns a Boolean value that indicates whether the specified &lt;xref:System.Type&gt; is allowed to be client activated.</summary>
        <returns>
          <see langword="true" /> if the specified &lt;xref:System.Type&gt; is allowed to be client activated; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The current method is used at the server end to determine whether an activation of the object <xref:System.Type> is explicitly allowed by the server.  
  
   
  
## Examples  
 [!code-cs[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/csharp/m-system.runtime.remotin_30_1.cs)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_30_1.vb)]
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/cpp/m-system.runtime.remotin_30_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(class System.Type svrType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">The object type to check.</param>
        <summary>Checks whether the specified object &lt;xref:System.Type&gt; is registered as a remotely activated client type.</summary>
        <returns>The <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> that corresponds to the specified object type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/cpp/3c46e8e7-ec3a-4a5f-8592-_1.cpp)]
 [!code-cs[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/csharp/3c46e8e7-ec3a-4a5f-8592-_1.cs)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/visualbasic/3c46e8e7-ec3a-4a5f-8592-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">The type name of the object to check.</param>
        <param name="assemblyName">The assembly name of the object to check.</param>
        <summary>Checks whether the object specified by its type name and assembly name is registered as a remotely activated client type.</summary>
        <returns>The <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> that corresponds to the specified object type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/cpp/12883156-dae9-4c9d-b176-_1.cpp)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/visualbasic/12883156-dae9-4c9d-b176-_1.vb)]
 [!code-cs[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/csharp/12883156-dae9-4c9d-b176-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(class System.Type svrType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">The object &lt;xref:System.Type&gt; to check.</param>
        <summary>Checks whether the specified object &lt;xref:System.Type&gt; is registered as a well-known client type.</summary>
        <returns>The <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> that corresponds to the specified object type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cs[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/csharp/e5a3d3ea-9352-4b35-bf3c-_1.cs)]
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/cpp/e5a3d3ea-9352-4b35-bf3c-_1.cpp)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/visualbasic/e5a3d3ea-9352-4b35-bf3c-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">The type name of the object to check.</param>
        <param name="assemblyName">The assembly name of the object to check.</param>
        <summary>Checks whether the object specified by its type name and assembly name is registered as a well-known client type.</summary>
        <returns>The <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> that corresponds to the specified object type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/cpp/2bdef175-1df9-4504-8b1f-_1.cpp)]
 [!code-cs[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/csharp/2bdef175-1df9-4504-8b1f-_1.cs)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/visualbasic/2bdef175-1df9-4504-8b1f-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ProcessId">
      <MemberSignature Language="C#" Value="public static string ProcessId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProcessId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the ID of the currently executing process.</summary>
        <value>A &lt;xref:System.String&gt; that contains the ID of the currently executing process.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">For operating with infrastructure code. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Runtime.Remoting.ActivatedClientTypeEntry entry) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Configuration settings for the client-activated type.</param>
        <summary>Registers an object &lt;xref:System.Type&gt; recorded in the provided <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> on the client end as a type that can be activated on the server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.  
  
 To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  
  
 For a detailed description of client-activated objects, see [&#91;\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (Type type, string appUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Type type, string appUrl) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="appUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The object &lt;xref:System.Type&gt;.</param>
        <param name="appUrl">URL of the application where this type is activated.</param>
        <summary>Registers an object &lt;xref:System.Type&gt; on the client end as a type that can be activated on the server, using the given parameters to initialize a new instance of the <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.  
  
 To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the RegisterActivatedClientType method. Calling the RegisterActivatedClientType method gives the remoting infrastructure the location of the remote application where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  
  
 For a detailed description of client-activated objects, see [&#91;\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)  
  
   
  
## Examples  
 The following code example demonstrates registration of an object type on the client end as a type that can be activated on the server. For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.  
  
 [!code-cs[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/csharp/c2dd353b-ad06-48e7-888a-_1.cs)]
 [!code-cpp[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/cpp/c2dd353b-ad06-48e7-888a-_1.cpp)]
 [!code-vb[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/visualbasic/c2dd353b-ad06-48e7-888a-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="typeName" /> or <paramref name="URI" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Runtime.Remoting.ActivatedServiceTypeEntry entry) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Configuration settings for the client-activated type.</param>
        <summary>Registers an object type recorded in the provided <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> on the service end as one that can be activated on request from a client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=fullName>.  
  
 To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  
  
 For a detailed description of client-activated objects, see [&#91;\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The &lt;xref:System.Type&gt; of object to register.</param>
        <summary>Registers a specified object type on the service end as a type that can be activated on request from a client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the RegisterActivatedServiceType method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=fullName>.  
  
 To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  
  
 For a detailed description of client-activated objects, see [&#91;\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a).  
  
   
  
## Examples  
 The following code example demonstrates registration of an object type on the server as a type that can be activated by the client. For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/cpp/47d0882a-e55a-42b9-abb6-_1.cpp)]
 [!code-vb[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/visualbasic/47d0882a-e55a-42b9-abb6-_1.vb)]
 [!code-cs[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/csharp/47d0882a-e55a-42b9-abb6-_1.cs)]  
  
 The following code example shows the service object registered in the sample code above.  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/cpp/47d0882a-e55a-42b9-abb6-_2.cpp)]
 [!code-vb[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/visualbasic/47d0882a-e55a-42b9-abb6-_2.vb)]
 [!code-cs[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/csharp/47d0882a-e55a-42b9-abb6-_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Runtime.Remoting.WellKnownClientTypeEntry entry) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Configuration settings for the well-known type.</param>
        <summary>Registers an object &lt;xref:System.Type&gt; recorded in the provided <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> on the client end as a well-known type that can be activated on the server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=fullName>. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  
  
 For a detailed description of well-known objects, see [&#91;\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (Type type, string objectUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Type type, string objectUrl) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The object &lt;xref:System.Type&gt;.</param>
        <param name="objectUrl">URL of a well-known client object.</param>
        <summary>Registers an object &lt;xref:System.Type&gt; on the client end as a well-known type that can be activated on the server, using the given parameters to initialize a new instance of the <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=fullName>. To activate a well-known object with `new`, you must first register the well-known object type on the client using the RegisterWellKnownClientType method. Calling the RegisterWellKnownClientType method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  
  
 For a detailed description of well-known objects, see [&#91;\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 The following code example demonstrates registration of an object type on the client end as a well-known type. For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> method.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_1.cpp)]
 [!code-cs[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_1.cs)]
 [!code-vb[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_1.vb)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_2.cpp)]
[!code-cs[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_2.cs)]
[!code-vb[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_2.vb)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_3.cpp)]
[!code-cs[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_3.cs)]
[!code-vb[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_3.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Runtime.Remoting.WellKnownServiceTypeEntry entry) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">Configuration settings for the well-known type.</param>
        <summary>Registers an object &lt;xref:System.Type&gt; recorded in the provided <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> on the service end as a well-known type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  
  
 When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object. If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode>, it is destroyed after the method call is completed. A new instance of the object is created for each method called. The only difference between <xref:System.Activator.GetObject%2A?displayProperty=fullName> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.  
  
 The remote object itself is not instantiated by the registration process. This only happens when a client attempts to call a method on the object or activates the object from the client side.  
  
 For a detailed description of well-known objects, see [&#91;\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 [!code-cs[CreateObjRef2#2](~/add/codesnippet/csharp/5b43d3ef-403f-408d-a561-_1.cs)]
 [!code-vb[CreateObjRef2#2](~/add/codesnippet/visualbasic/5b43d3ef-403f-408d-a561-_1.vb)]
 [!code-cpp[CreateObjRef2#2](~/add/codesnippet/cpp/5b43d3ef-403f-408d-a561-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Type type, string objectUri, valuetype System.Runtime.Remoting.WellKnownObjectMode mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUri" Type="System.String" />
        <Parameter Name="mode" Type="System.Runtime.Remoting.WellKnownObjectMode" />
      </Parameters>
      <Docs>
        <param name="type">The object &lt;xref:System.Type&gt;.</param>
        <param name="objectUri">The object URI.</param>
        <param name="mode">The activation mode of the well-known object type being registered. (See <see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />.)</param>
        <summary>Registers an object &lt;xref:System.Type&gt; on the service end as a well-known type, using the given parameters to initialize a new instance of <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  
  
 When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object. If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode>, it is destroyed after the method call is completed. A new instance of the object is created for each method called. The only difference between <xref:System.Activator.GetObject%2A?displayProperty=fullName> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.  
  
 The remote object itself is not instantiated by the registration process. This only happens when a client attempts to call a method on the object or activates the object from the client side.  
  
 For a detailed description of well-known objects, see [&#91;\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396).  
  
   
  
## Examples  
 The following code example demonstrates registration of an object type on the server as a well-known object type. For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.  
  
 [!code-cs[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_1.cs)]
 [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_1.cpp)]
 [!code-vb[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_1.vb)]  
[!code-cs[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_2.cs)]
[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_2.cpp)]
[!code-vb[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_2.vb)]  
[!code-cs[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_3.cs)]
[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_3.cpp)]
[!code-vb[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_3.vb)]  
  
 The following code example shows the service object registered in the sample code above.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_4.cpp)]
 [!code-cs[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_4.cs)]
 [!code-vb[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_4.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="T:System.Security.Permissions.SecurityAction" />; Permission value: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>