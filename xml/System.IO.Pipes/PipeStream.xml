<Type Name="PipeStream" FullName="System.IO.Pipes.PipeStream">
  <TypeSignature Language="C#" Value="public abstract class PipeStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract PipeStream extends System.IO.Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Exposes a &lt;xref:System.IO.Stream&gt; object around a pipe, which supports both anonymous and named pipes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The PipeStream class provides the base class for named and anonymous pipes operations in the .NET Framework. Use the <xref:System.IO.Pipes.NamedPipeServerStream> and <xref:System.IO.Pipes.NamedPipeClientStream> classes for named pipe operations. Use the <xref:System.IO.Pipes.AnonymousPipeServerStream> and <xref:System.IO.Pipes.AnonymousPipeClientStream> classes for anonymous pipe operations.  
  
 For more information about pipes, see [Pipes](~/add/includes/ajax-current-ext-md.md). For an example of anonymous pipes, see [How to: Use Anonymous Pipes for Local Interprocess Communication](~/add/includes/ajax-current-ext-md.md). For an example of named pipes, see [How to: Use Named Pipes for Network Interprocess Communication](~/add/includes/ajax-current-ext-md.md).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This class cannot be inherited by partially trusted code.</permission>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, int32 bufferSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</param>
        <param name="bufferSize">A positive &lt;xref:System.Int32&gt; value greater than or equal to 0 that indicates the buffer size.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" /> value and buffer size.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This constructor uses a pipe transmission mode of <xref:System.IO.Pipes.PipeTransmissionMode>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.  
  
 -or-  
  
 <paramref name="bufferSize" /> is less than 0.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, int32 outBufferSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</param>
        <param name="transmissionMode">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode of the pipe object.</param>
        <param name="outBufferSize">A positive &lt;xref:System.Int32&gt; value greater than or equal to 0 that indicates the buffer size.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, and buffer size.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.  
  
 -or-  
  
 <paramref name="transmissionMode" /> is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.  
  
 -or-  
  
 <paramref name="bufferSize" /> is less than 0.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer to read data into.</param>
        <param name="offset">The byte offset in `buffer` at which to begin reading.</param>
        <param name="count">The maximum number of bytes to read.</param>
        <param name="callback">The method to call when the asynchronous read operation is completed.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
        <summary>Begins an asynchronous read operation.</summary>
        <returns>An &lt;xref:System.IAsyncResult&gt; object that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading. <xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to BeginRead. This can be done either in the same code that called BeginRead or in a callback that is passed to BeginRead.  
  
 Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.  
  
 If the pipe is closed or an invalid argument is passed to BeginRead, the appropriate exceptions are raised immediately. Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request. The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer that contains the data to write to the current stream.</param>
        <param name="offset">The zero-based byte offset in `buffer` at which to begin copying bytes to the current stream.</param>
        <param name="count">The maximum number of bytes to write.</param>
        <param name="callback">The method to call when the asynchronous write operation is completed.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
        <summary>Begins an asynchronous write operation.</summary>
        <returns>An &lt;xref:System.IAsyncResult&gt; object that references the asynchronous write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to BeginWrite. This can be done either in the same code that called BeginWrite or in a callback that is passed to BeginWrite.  
  
 Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.  
  
 If the pipe is closed or an invalid argument is passed to BeginWrite, the appropriate exceptions are raised immediately. Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request. The exceptions are raised when the code calls the  <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current stream supports read operations.</summary>
        <value>
          <see langword="true" /> if the stream supports read operations; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current stream supports seek operations.</summary>
        <value>
          <see langword="false" /> in all cases.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current stream supports write operations.</summary>
        <value>
          <see langword="true" /> if the stream supports write operations; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected virtual void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifies that the pipe is in a proper state for getting or setting properties.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CheckReadOperations">
      <MemberSignature Language="C#" Value="protected void CheckReadOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckReadOperations() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifies that the pipe is in a connected state for read operations.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CheckWriteOperations">
      <MemberSignature Language="C#" Value="protected void CheckWriteOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckWriteOperations() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifies that the pipe is in a connected state for write operations.</summary>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.Pipes.PipeStream" /> class and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method. <xref:System.ComponentModel.Component.Dispose%2A> invokes the protected Dispose method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes Dispose with `disposing` set to `false`. When the disposing parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Pipes.PipeStream> object references. This method invokes the Dispose method of each referenced object.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The reference to the pending asynchronous request.</param>
        <summary>Ends a pending asynchronous read request.</summary>
        <returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method returns the number of bytes read into the byte array specified by the earlier call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.  
  
 Pass the returned <xref:System.IAsyncResult> object to the EndRead method to determine how many bytes were read and to release operating system resources used for reading. EndRead must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>. This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.  
  
 Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.  
  
 If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately. Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request. The exceptions are raised when the code calls the EndRead method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> did not originate from a &lt;xref:System.IO.Pipes.PipeStream.BeginRead%2A&gt; method on the current stream.</exception>
        <exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The reference to the pending asynchronous request.</param>
        <summary>Ends a pending asynchronous write request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 EndWrite must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>. This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.  
  
 Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.  
  
 If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately. Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request. The exceptions are raised when the code the calls EndWrite method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> did not originate from a &lt;xref:System.IO.Pipes.PipeStream.BeginWrite%2A&gt; method on the current stream.</exception>
        <exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Flush method is not supported in the <xref:System.IO.Pipes.PipeStream> class and does nothing when it is called.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.Pipes.PipeSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Pipes.PipeSecurity GetAccessControl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</summary>
        <returns>A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file. For more information, see [How to: Add or Remove Access Control List Entries](~/add/includes/ajax-current-ext-md.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception>
        <exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="InBufferSize">
      <MemberSignature Language="C#" Value="public virtual int InBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
        <value>An integer value that represents the inbound buffer size, in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If InBufferSize is 0, the buffer size is allocated as needed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The stream is unreadable.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="InitializeHandle">
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeHandle(class Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
        <Parameter Name="isExposed" Type="System.Boolean" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">The <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object of the pipe to initialize.</param>
        <param name="isExposed">
          <see langword="true" /> to expose the handle; otherwise, <see langword="false" />.</param>
        <param name="isAsync">
          <see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</param>
        <summary>Initializes a <see cref="T:System.IO.Pipes.PipeStream" /> object from the specified <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the pipe is in a connected state, this method also sets the <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property to `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A handle cannot be bound to the pipe.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously or synchronously.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property enables your code to use the <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> property correctly.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public bool IsConnected { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object is connected.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object is connected; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The IsConnected property returns `true` only if the <xref:System.IO.Pipes.PipeStream> object is connected. If this property returns `false`, the pipe may be waiting to connect, or may be disconnected, closed, or broken.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsHandleExposed">
      <MemberSignature Language="C#" Value="protected bool IsHandleExposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleExposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a handle to a <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed.</summary>
        <value>
          <see langword="true" /> if a handle to the <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The value of this property is set when obtaining a handle to the pipe that is encapsulated by the current <xref:System.IO.Pipes.PipeStream> object.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsMessageComplete">
      <MemberSignature Language="C#" Value="public bool IsMessageComplete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMessageComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
        <value>
          <see langword="true" /> if there are no more characters to read in the message; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property is relevant if the pipe's <xref:System.IO.Pipes.PipeStream.ReadMode%2A> property was set to <xref:System.IO.Pipes.PipeTransmissionMode> by the most recent call to <xref:System.IO.Pipes.PipeStream.Read%2A> or <xref:System.IO.Pipes.PipeStream.EndRead%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The pipe is not connected.  
  
 -or-  
  
 The pipe handle has not been set.  
  
 -or-  
  
 The pipe's &lt;xref:System.IO.Pipes.PipeStream.ReadMode%2A&gt; property value is not <see cref="T:System.IO.Pipes.PipeTransmissionMode" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of a stream, in bytes.</summary>
        <value>0 in all cases.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.IO.Pipes.PipeStream> class does not support the Length property.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="OutBufferSize">
      <MemberSignature Language="C#" Value="public virtual int OutBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
        <value>The outbound buffer size, in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If OutBufferSize is 0, the buffer size is allocated as needed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position of the current stream.</summary>
        <value>0 in all cases.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.IO.Pipes.PipeStream> class does not support the Position property.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">When this method returns, contains the specified byte array with the values between `offset` and (`offset` + `count` - 1) replaced by the bytes read from the current source.</param>
        <param name="offset">The byte offset in the `buffer` array at which the bytes that are read will be placed.</param>
        <param name="count">The maximum number of bytes to read.</param>
        <summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
        <returns>The total number of bytes that are read into <paramref name="buffer" />. This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.  
  
 Calling the Read method blocks until `count` bytes are read or the end of the stream is reached. For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginRead%2A> and <xref:System.IO.Pipes.PipeStream.EndRead%2A>.  
  
   
  
## Examples  
 The following example creates an anonymous pipe client and pipe server. The pipe server uses the Read method to read a series of bytes from the pipe client as a validation code. Both the pipe client and the pipe server are part of the same example. The server portion of the example creates a client process and passes it an anonymous pipe handle as an argument.  
  
 [!code-cs[System.IO.Pipes.PipeStream#1](~/add/codesnippet/csharp/m-system.io.pipes.pipest_1.cs)]
 [!code-vb[System.IO.Pipes.PipeStream#1](~/add/codesnippet/visualbasic/m-system.io.pipes.pipest_1.vb)]
 [!code-cpp[System.IO.Pipes.PipeStream#1](~/add/codesnippet/cpp/m-system.io.pipes.pipest_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
        <exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads a byte from a pipe.</summary>
        <returns>The byte, cast to &lt;xref:System.Int32&gt;, or -1 indicates the end of the stream (the pipe has been closed).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
        <exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode ReadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" /> object.</summary>
        <value>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" /> object reads from the pipe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode> mode message transmission.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</exception>
        <exception cref="T:System.NotSupportedException">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value for this pipe stream.</exception>
        <exception cref="T:System.InvalidOperationException">The handle has not been set.  
  
 -or-  
  
 The pipe is waiting to connect with a named client.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred with a named client.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" /> object encapsulates.</summary>
        <value>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">The point, relative to `origin`, to begin seeking from.</param>
        <param name="origin">Specifies the beginning, the end, or the current position as a reference point for `offset`, using a value of type &lt;xref:System.IO.SeekOrigin&gt;.</param>
        <summary>Sets the current position of the current stream to the specified value.</summary>
        <returns>The new position in the stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Seek method is not supported in pipes and raises a <xref:System.NotSupportedException> when it is called.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
        <summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" /> object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file. For more information, see [How to: Add or Remove Access Control List Entries](~/add/includes/ajax-current-ext-md.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception>
        <exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception>
        <exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The new length of the stream.</param>
        <summary>Sets the length of the current stream to the specified value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.IO.Pipes.PipeStream> class does not support the SetLength method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the pipe transmission mode supported by the current pipe.</summary>
        <value>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode supported by the current pipe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode> mode message transmission.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.InvalidOperationException">The handle has not been set.  
  
 -or-  
  
 The pipe is waiting to connect in an anonymous client/server operation or with a named client.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="WaitForPipeDrain">
      <MemberSignature Language="C#" Value="public void WaitForPipeDrain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForPipeDrain() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Waits for the other end of the pipe to read all sent bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The WaitForPipeDrain method blocks until the other end of the pipe has read all sent bytes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer that contains data to write to the pipe.</param>
        <param name="offset">The zero-based byte offset in `buffer` at which to begin copying bytes to the current stream.</param>
        <param name="count">The maximum number of bytes to write to the current stream.</param>
        <summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.  
  
 Calling the Write method blocks until `count` bytes are read or the end of the stream is reached. For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> and <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
        <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
        <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
        <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>