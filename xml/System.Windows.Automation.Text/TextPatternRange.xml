<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a span of continuous text in a <see cref="T:System.Windows.Automation.TextPattern" /> container.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A TextPatternRange can represent an insertion point, a subset, or all of the text in a <xref:System.Windows.Automation.TextPattern> container.  
  
 A TextPatternRange will become invalid if one of the following occurs: the text in the <xref:System.Windows.Automation.TextPattern> container changes because of some user activity, or the <xref:System.Windows.Automation.ValuePattern.SetValue%2A> method of <xref:System.Windows.Automation.ValuePattern> is used to programmatically change the value of the text in the <xref:System.Windows.Automation.TextPattern> container.  
  
 ]]></format>
    </remarks>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adds to the collection of highlighted text in a text container that supports multiple, disjoint selections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The text insertion point moves to the area of the new selection.  
  
 Providing a degenerate text range moves the insertion point.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">If text provider does not support multiple, disjoint selections (for example, &lt;xref:System.Windows.Automation.TextPattern.SupportedTextSelection%2A&gt; must have a value of <see langword="Multiple" />).</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves a new <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> identical to the original <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> and inheriting all properties of the original.</summary>
        <returns>The new text range. A null reference (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]) is never returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alternatively, create a new <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> from the <xref:System.Windows.Automation.TextPattern> and move the two endpoints to correspond with the endpoints of the original text range.  
  
 The new range can be manipulated independently from the original.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1060](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">A text range to compare.</param>
        <summary>Returns a &lt;xref:System.Boolean&gt; value indicating whether the span (the <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> endpoint to the <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> endpoint) of a text range is the same as another text range.</summary>
        <returns>
          <see langword="true" /> if the span of both text ranges is identical; otherwise <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cs[UIATextPattern_snip#1061](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">If the range being compared does not come from the same text provider.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">The <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> or <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> endpoint of the caller.</param>
        <param name="targetRange">The target range for comparison.</param>
        <param name="targetEndpoint">The <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> or <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> endpoint of the target.</param>
        <summary>Returns an &lt;xref:System.Int32&gt; indicating whether two text ranges have identical endpoints.</summary>
        <returns>Returns a negative value if the caller's endpoint occurs earlier in the text than the target endpoint.  
  
 Returns zero if the caller's endpoint is at the same location as the target endpoint.  
  
 Returns a positive value if the caller's endpoint occurs later in the text than the target endpoint.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 By comparing the starting and ending endpoints of the same text range you can identify if a text range is degenerate or if the endpoints are in the order of logical text flow.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1062](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">If range is a null reference (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]).</exception>
        <exception cref="T:System.ArgumentException">If range is from another container.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">The textual unit.</param>
        <summary>Expands the text range to the specified <see cref="T:System.Windows.Automation.Text.TextUnit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the range is already an exact quantity of the specified units then it remains unchanged.  
  
 In order for the ExpandToEnclosingUnit method to execute successfully, a sequence of actions is performed behind the scenes.  
  
1.  The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint, making the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint superfluous. This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [http://www.microsoft.com](http://www.microsoft.com) is embedded in text" where "{" and "}" are the text range endpoints.  
  
2.  The resulting range is moved backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to the beginning of the requested `unit` boundary.  
  
3.  The range is moved forward or backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> by the requested number of `unit` boundaries.  
  
4.  The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint by one requested `unit` boundary.  
  
 ![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")  
Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()  
  
> [!NOTE]
>  These steps are necessary since it is common for a screen reader to read out a full word, sentence, or entire paragraph at the insertion point or any virtual cursor position.  
  
 ExpandToEnclosingUnit respects both hidden and visible text. The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.  
  
 ExpandToEnclosingUnit defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.  
  
 The order, from smallest unit to largest, is listed below.  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1063](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">The attribute to search for.</param>
        <param name="value">The attribute value to search for. This value must match the type specified for the attribute.</param>
        <param name="backward">
          <see langword="true" /> if the last occurring text range should be returned instead of the first; otherwise <see langword="false" />.</param>
        <summary>Returns a text range subset that has the specified attribute value.</summary>
        <returns>A text range having a matching attribute and attribute value; otherwise null (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 There is no differentiation between hidden and visible text. UI Automation clients can use <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> to check text visibility.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to search the entire document.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1064](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">The text string to search for.</param>
        <param name="backward">
          <see langword="true" /> if the last occurring text range should be returned instead of the first; otherwise <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> if case should be ignored; otherwise <see langword="false" />.</param>
        <summary>Returns a text range subset that contains the specified text.</summary>
        <returns>A text range matching the specified text; otherwise null (<see langword="Nothing" /> in [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 There is no differentiation between hidden and visible text. UI Automation clients can use <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> to check text visibility.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to search the entire document.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1065](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">The text attribute.</param>
        <summary>Returns the value of the specified attribute across the entire text range.</summary>
        <returns>Returns the value of the specified attribute. For example, GetAttributeValue(TextPattern.FontNameAttribute) would return a string that represents the font name, if unique, of the text range while GetAttributeValue(TextPattern.IsItalicAttribute) would return a boolean.  
  
 Returns <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> if the value of the specified attribute varies over the text range.  
  
 Returns <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> if the specified attribute is not supported by the provider or the control.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 There is no differentiation between hidden and visible text. UI Automation clients can use <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> to check text visibility.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1066](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">If the specified attribute is not valid.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves a collection of bounding rectangles for each fully or partially visible line of text in a text range.</summary>
        <returns>An array of bounding rectangles for each full or partial line of text in a text range.  
  
 An empty array for a degenerate text range.  
  
 An empty array for a text range that has screen coordinates placing it completely off-screen, scrolled out of view, or obscured by an overlapping window.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cs[UIATextPattern_snip#1067](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves a collection of all embedded objects that fall within the text range.</summary>
        <returns>A collection of all child objects that fall within the range. Children that overlap with the range but are not entirely enclosed by it will also be included in the collection.  
  
 Returns an empty collection if there are no child objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]
 [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  
[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]
[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#getembeddedobjects)]
[!code-cs[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the innermost <see cref="T:System.Windows.Automation.AutomationElement" /> that encloses the text range.</summary>
        <returns>The innermost element enclosing the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The enclosing <xref:System.Windows.Automation.AutomationElement>, typically the text provider that supplies the text range. However, if the text provider supports child elements such as tables or hyperlinks, then the enclosing element could be a descendant of the text provider.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1069](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">The maximum length of the string to return. Use `-1` if no limit is required.</param>
        <summary>Returns the plain text of the text range.</summary>
        <returns>The plain text of the text range, possibly truncated at the specified <paramref name="maxLength" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetText respects both hidden and visible text. The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.  
  
 If `maxLength` is greater than the length of the text span of the caller, the string returned will be the plain text of the text range.  
  
 GetText will not be affected by the order of endpoints in the text flow; it will always return the text between the Start and End endpoints of the text range in the logical text flow order.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1070](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="maxLength" /> is less than -1.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">The text unit boundary.</param>
        <param name="count">The number of text units to move. A positive value moves the text range forward, a negative value moves the text range backward, and 0 has no effect.</param>
        <summary>Moves the text range the specified number of text units.</summary>
        <returns>The number of units actually moved. This can be less than the number requested if either of the new text range endpoints is greater than or less than the &lt;xref:System.Windows.Automation.TextPattern.DocumentRange%2A&gt; endpoints.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When it is necessary to traverse the content of a text range, a series of steps are involved behind the scenes in order for the Move method to execute successfully.  
  
1.  The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint superfluous. This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [http://www.microsoft.com](http://www.microsoft.com) is embedded in text" where "{" and "}" are the text range endpoints.  
  
2.  The resulting range is moved backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to the beginning of the requested `unit` boundary.  
  
3.  The range is moved forward or backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> by the requested number of `unit` boundaries.  
  
4.  The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint by one requested `unit` boundary.  
  
 ![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")  
Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()  
  
 The textual content (or inner text) of a text container and an embedded object, such as a hyperlink or table cell, is exposed as a single, continuous text stream in both the control view and the content view of the [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] tree; object boundaries are ignored. If a UI Automation client is retrieving the text for the purpose of reciting, interpreting, or analyzing in some manner, the text range should be checked for special cases, such as a table with textual content or other embedded objects. This can be accomplished by calling <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> to obtain an <xref:System.Windows.Automation.AutomationElement> for each embedded object and then calling <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> to obtain a text range for each element; this is done recursively until all textual content has been retrieved.  
  
 ![Text ranges spanned by embedded objects.](~/add/media/uia-textpattern-embeddedobjecttextranges.png "Text ranges spanned by embedded objects.")  
Example of a text stream with embedded objects and their range spans  
  
 Move respects both hidden and visible text. The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.  
  
 Move defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.  
  
 The order, from smallest unit to largest, is listed below.  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
> [!NOTE]
>  The text is not altered in any way as the text range just spans a different part of the text.  
  
   
  
## Examples  
 [!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]
 [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  
[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]
[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  
[!code-vb[UIATextPattern_snip#MoveSelection](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#moveselection)]
[!code-cs[UIATextPattern_snip#MoveSelection](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#moveselection)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">The endpoint to move.</param>
        <param name="targetRange">Another range from the same text provider.</param>
        <param name="targetEndpoint">An endpoint on the other range.</param>
        <summary>Moves one endpoint of a text range to the specified endpoint of a second text range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the endpoint being moved crosses the other endpoint of the same text range then that other endpoint is moved also, resulting in a degenerate range and ensuring the correct ordering of the endpoints (that is, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> is always less than or equal to <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>).  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1072](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">The endpoint to move.</param>
        <param name="unit">The textual unit for moving.</param>
        <param name="count">The number of units to move. A positive count moves the endpoint forward. A negative count moves backward. A count of 0 has no effect.</param>
        <summary>Moves one endpoint of the text range the specified number of <see cref="T:System.Windows.Automation.Text.TextUnit" />s within the document range.</summary>
        <returns>The number of units actually moved, which can be less than the number requested if moving the endpoint runs into the beginning or end of the document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When it is necessary to traverse the content of a text range, a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> method to execute successfully.  
  
1.  The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint superfluous. This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [http://www.microsoft.com](http://www.microsoft.com) is embedded in text" where "{" and "}" are the text range endpoints.  
  
2.  The resulting range is moved backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to the beginning of the requested `unit` boundary.  
  
3.  The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint by one requested `unit` boundary.  
  
 ![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")  
Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()  
  
 The textual content (or inner text) of a text container and an embedded object, such as a hyperlink or table cell, is exposed as a single, continuous text stream in both the control view and the content view of the [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] tree; object boundaries are ignored. If a UI Automation client is retrieving the text for the purpose of reciting, interpreting, or analyzing in some manner, the text range should be checked for special cases, such as a table with textual content or other embedded objects. This can be accomplished by calling <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> to obtain an <xref:System.Windows.Automation.AutomationElement> for each embedded object and then calling <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> to obtain a text range for each element; this is done recursively until all textual content has been retrieved.  
  
 ![Text ranges spanned by embedded objects.](~/add/media/uia-textpattern-embeddedobjecttextranges.png "Text ranges spanned by embedded objects.")  
Example of a text stream with embedded objects and their range spans  
  
 MoveEndpointByUnit defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.  
  
 The order, from smallest unit to largest, is listed below.  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
-   <xref:System.Windows.Automation.Text.TextUnit>  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1073](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes a highlighted section of text, corresponding to the calling text range <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> and <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> endpoints, from an existing collection of highlighted text in a text container that supports multiple, disjoint selections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The text insertion point will move to the area of the removed highlight.  
  
 Providing a degenerate text range will move the insertion point.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">If text provider does not support multiple, disjoint selections (for example, &lt;xref:System.Windows.Automation.TextPattern.SupportedTextSelection%2A&gt; must have a value of <see langword="Multiple" />).</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" /> if the text control should be scrolled so the text range is flush with the top of the viewport; <see langword="false" /> if it should be flush with the bottom of the viewport.</param>
        <summary>Causes the text control to scroll vertically until the text range is visible in the viewport.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ScrollIntoView respects both hidden and visible text. The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility. If the text range is hidden, the text control will scroll only if the hidden text has an anchor in the viewport.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1074](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">If scrolling is not supported by the control.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Highlights text in the text control corresponding to the text range <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> and <see cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" /> endpoints.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If a degenerate text range is provided, the text insertion point will move to the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> endpoint of the text range.  
  
   
  
## Examples  
 [!code-cs[UIATextPattern_snip#1075](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Occurs when text selection is not supported by the text control.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.Automation.TextPattern" /> associated with the text range.</summary>
        <value>The text provider.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cs[UIATextPattern_snip#1076](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>