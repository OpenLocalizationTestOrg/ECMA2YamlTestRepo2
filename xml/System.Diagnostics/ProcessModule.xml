<Type Name="ProcessModule" FullName="System.Diagnostics.ProcessModule">
  <TypeSignature Language="C#" Value="public class ProcessModule : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessModule extends System.ComponentModel.Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessModuleDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a.dll or .exe file that is loaded into a particular process.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A module is an executable file or a dynamic link library (DLL). Each process consists of one or more modules. You can use this class to get information about the module.  
  
> [!IMPORTANT]
>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  
  
   
  
## Examples  
 The following code sample demonstrates how to use the ProcessModule class to get and display information about all the modules that are used by the Notepad.exe application.  
  
 [!code-cpp[ProcessModule#1](../../add/codesnippet/CPP/t-system.diagnostics.pro_0_1.cpp)]
 [!code-cs[ProcessModule#1](../../add/codesnippet/CSharp/t-system.diagnostics.pro_0_1.cs)]
 [!code-vb[ProcessModule#1](../../add/codesnippet/VisualBasic/t-system.diagnostics.pro_0_1.vb)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">for full trust for the immediate caller. This class cannot be used by partially trusted code.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This class cannot be inherited by partially trusted code.</permission>
    <threadsafe />
    <returns />
    <value />
  </Docs>
  <Members>
    <Member MemberName="BaseAddress">
      <MemberSignature Language="C#" Value="public IntPtr BaseAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int BaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcModBaseAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the memory address where the module was loaded.</summary>
        <value>The load address of the module.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The <xref:System.Diagnostics.ProcessModule.ModuleName%2A> and  BaseAddress properties are used to display the module name and the memory address where each module was loaded.  
  
 [!code-cpp[ProcessModule_BaseAddress#1](../../add/codesnippet/CPP/p-system.diagnostics.pro_30_1.cpp)]
 [!code-vb[ProcessModule_BaseAddress#1](../../add/codesnippet/VisualBasic/p-system.diagnostics.pro_30_1.vb)]
 [!code-cs[ProcessModule_BaseAddress#1](../../add/codesnippet/CSharp/p-system.diagnostics.pro_30_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <returns>The load address of the module.</returns>
      </Docs>
    </Member>
    <Member MemberName="EntryPointAddress">
      <MemberSignature Language="C#" Value="public IntPtr EntryPointAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int EntryPointAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcModEntryPointAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the memory address for the function that runs when the system loads and runs the module.</summary>
        <value>The entry point of the module.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The module's entry point is the location of the function that is called during process startup, thread startup, process shutdown, and thread shutdown. While the entry point is not the address of the DllMain function, it should be close enough for most purposes.  
  
> [!NOTE]
>  Due to changes in the way that Windows loads assemblies, EntryPointAddress will always return 0 on [!INCLUDE[win8](../../add/includes/win8-md.md)] or [!INCLUDE[win81](../../add/includes/win81-md.md)] and should not be relied on for those platforms.  
  
   
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The <xref:System.Diagnostics.ProcessModule.ModuleName%2A> and EntryPointAddress properties are used to display the name and the entry point address for each module.  
  
 [!code-cpp[ProcessModule_EntryPoint#1](../../add/codesnippet/CPP/p-system.diagnostics.pro_4_1.cpp)]
 [!code-cs[ProcessModule_EntryPoint#1](../../add/codesnippet/CSharp/p-system.diagnostics.pro_4_1.cs)]
 [!code-vb[ProcessModule_EntryPoint#1](../../add/codesnippet/VisualBasic/p-system.diagnostics.pro_4_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <returns>The entry point of the module.</returns>
      </Docs>
    </Member>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcModFileName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the full path to the module.</summary>
        <value>The fully qualified path that defines the location of the module.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the file name is longer than the maximum number of characters allowed, the file name is truncated.  
  
   
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The <xref:System.Diagnostics.ProcessModule.ModuleName%2A> and FileName properties are used to display the module name and the full path information for each module.  
  
 [!code-cs[ProcessModule_FileName#1](../../add/codesnippet/CSharp/p-system.diagnostics.pro_5_1.cs)]
 [!code-cpp[ProcessModule_FileName#1](../../add/codesnippet/CPP/p-system.diagnostics.pro_5_1.cpp)]
 [!code-vb[ProcessModule_FileName#1](../../add/codesnippet/VisualBasic/p-system.diagnostics.pro_5_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <returns>The fully qualified path that defines the location of the module.</returns>
      </Docs>
    </Member>
    <Member MemberName="FileVersionInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.FileVersionInfo FileVersionInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.FileVersionInfo FileVersionInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.FileVersionInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets version information about the module.</summary>
        <value>A <see cref="T:System.Diagnostics.FileVersionInfo" /> that contains the module's version information.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The <xref:System.Diagnostics.ProcessModule.ModuleName%2A> and FileVersionInfo properties are used to display the module name and the file version information for each module.  
  
 [!code-cs[ProcessModule_FileVersionInfo#1](../../add/codesnippet/CSharp/p-system.diagnostics.pro_1_1.cs)]
 [!code-cpp[ProcessModule_FileVersionInfo#1](../../add/codesnippet/CPP/p-system.diagnostics.pro_1_1.cpp)]
 [!code-vb[ProcessModule_FileVersionInfo#1](../../add/codesnippet/VisualBasic/p-system.diagnostics.pro_1_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <returns>A <see cref="T:System.Diagnostics.FileVersionInfo" /> that contains the module's version information.</returns>
      </Docs>
    </Member>
    <Member MemberName="ModuleMemorySize">
      <MemberSignature Language="C#" Value="public int ModuleMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ModuleMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcModModuleMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of memory that is required to load the module.</summary>
        <value>The size, in bytes, of the memory that the module occupies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ModuleMemorySize does not include any additional memory allocations that the module makes once it is running; it includes only the size of the static code and data in the module file.  
  
   
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The <xref:System.Diagnostics.ProcessModule.ModuleName%2A> and ModuleMemorySize properties are used to display the module name and the amount of memory needed for each module.  
  
 [!code-vb[ProcessModule_ModuleMemorySize#1](../../add/codesnippet/VisualBasic/p-system.diagnostics.pro_16_1.vb)]
 [!code-cs[ProcessModule_ModuleMemorySize#1](../../add/codesnippet/CSharp/p-system.diagnostics.pro_16_1.cs)]
 [!code-cpp[ProcessModule_ModuleMemorySize#1](../../add/codesnippet/CPP/p-system.diagnostics.pro_16_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <returns>The size, in bytes, of the memory that the module occupies.</returns>
      </Docs>
    </Member>
    <Member MemberName="ModuleName">
      <MemberSignature Language="C#" Value="public string ModuleName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ModuleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcModModuleName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the process module.</summary>
        <value>The name of the module.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the name is longer than the maximum number of characters allowed, it is truncated.  
  
   
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The ModuleName property is used to display the name of each module.  
  
 [!code-vb[ProcessModule_ModuleName#1](../../add/codesnippet/VisualBasic/p-system.diagnostics.pro_8_1.vb)]
 [!code-cs[ProcessModule_ModuleName#1](../../add/codesnippet/CSharp/p-system.diagnostics.pro_8_1.cs)]
 [!code-cpp[ProcessModule_ModuleName#1](../../add/codesnippet/CPP/p-system.diagnostics.pro_8_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <returns>The name of the module.</returns>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the name of the module to a string.</summary>
        <returns>The value of the &lt;xref:System.Diagnostics.ProcessModule.ModuleName%2A&gt; property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example creates a new process for the Notepad.exe application. The code iterates through the <xref:System.Diagnostics.ProcessModuleCollection> class to obtain a <xref:System.Diagnostics.ProcessModule> object for each module in the collection. The ToString method is used to display the name for each module.  
  
 [!code-cs[ProcessModule_ToString#1](../../add/codesnippet/CSharp/m-system.diagnostics.pro_5_1.cs)]
 [!code-vb[ProcessModule_ToString#1](../../add/codesnippet/VisualBasic/m-system.diagnostics.pro_5_1.vb)]
 [!code-cpp[ProcessModule_ToString#1](../../add/codesnippet/CPP/m-system.diagnostics.pro_5_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
        <value>The value of the &lt;xref:System.Diagnostics.ProcessModule.ModuleName%2A&gt; property.</value>
      </Docs>
    </Member>
  </Members>
</Type>