<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream">
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides the underlying stream of data for network access.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The NetworkStream class provides methods for sending and receiving data over <xref:System.Net.Sockets.SocketType> sockets in blocking mode. For more information about blocking versus nonblocking <xref:System.Net.Sockets.Socket>s, see [Using an Asynchronous Client Socket](~/add/includes/ajax-current-ext-md.md). You can use the NetworkStream class for both synchronous and asynchronous data transfer. For more information about synchronous and asynchronous communication, see [Sockets](~/add/includes/ajax-current-ext-md.md).  
  
 To create a NetworkStream, you must provide a connected <xref:System.Net.Sockets.Socket>. You can also specify what <xref:System.IO.FileAccess> permission the NetworkStream has over the provided <xref:System.Net.Sockets.Socket>. By default, closing the NetworkStream does not close the provided <xref:System.Net.Sockets.Socket>. If you want the NetworkStream to have permission to close the provided <xref:System.Net.Sockets.Socket>, you must specify `true` for the value of the `ownsSocket` parameter.  
  
 Use the <xref:System.Net.Sockets.NetworkStream.Write%2A> and <xref:System.Net.Sockets.NetworkStream.Read%2A> methods for simple single thread synchronous blocking I/O. If you want to process your I/O using separate threads, consider using the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> and <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> methods, or the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> and <xref:System.Net.Sockets.NetworkStream.EndRead%2A> methods for communication.  
  
 The NetworkStream does not support random access to the network data stream. The value of the <xref:System.Net.Sockets.NetworkStream.CanSeek%2A> property, which indicates whether the stream supports seeking, is always `false`; reading the <xref:System.Net.Sockets.NetworkStream.Position%2A> property, reading the <xref:System.Net.Sockets.NetworkStream.Length%2A> property, or calling the <xref:System.Net.Sockets.NetworkStream.Seek%2A> method will throw a <xref:System.NotSupportedException>.  
  
 Read and write operations can be performed simultaneously on an instance of the NetworkStream class without the need for synchronization. As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required.  
  
   
  
## Examples  
 The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]  
  
 ]]></format>
    </remarks>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <param name="socket">The &lt;xref:System.Net.Sockets.Socket&gt; that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified &lt;xref:System.Net.Sockets.Socket&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Net.Sockets.NetworkStream> is created with read/write access to the specified <xref:System.Net.Sockets.Socket>. The <xref:System.Net.Sockets.NetworkStream> does not own the underlying <xref:System.Net.Sockets.Socket>, so calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method does not close the <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
 -or-  
  
 The &lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt; property of the <paramref name="socket" /> parameter is not &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.  
  
 -or-  
  
 The <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">The &lt;xref:System.Net.Sockets.Socket&gt; that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="ownsSocket">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the &lt;xref:System.Net.Sockets.Socket&gt;; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified &lt;xref:System.Net.Sockets.Socket&gt; with the specified &lt;xref:System.Net.Sockets.Socket&gt; ownership.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Net.Sockets.NetworkStream> is created with read/write access to the specified <xref:System.Net.Sockets.Socket>. If the value of `ownsSocket` parameter is `true`, the <xref:System.Net.Sockets.NetworkStream> takes ownership of the underlying <xref:System.Net.Sockets.Socket>, and calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method also closes the underlying <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
 -or-  
  
 the value of the &lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt; property of the <paramref name="socket" /> parameter is not &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.  
  
 -or-  
  
 the <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="socket">The &lt;xref:System.Net.Sockets.Socket&gt; that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="access">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specify the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided &lt;xref:System.Net.Sockets.Socket&gt;.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified &lt;xref:System.Net.Sockets.Socket&gt; with the specified access rights.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Net.Sockets.NetworkStream> is created with the specified access to the specified <xref:System.Net.Sockets.Socket>. With this constructor, the <xref:System.Net.Sockets.NetworkStream> does not own the underlying <xref:System.Net.Sockets.Socket>, so calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method does not close the underlying <xref:System.Net.Sockets.Socket>.  
  
 The `access` parameter sets the <xref:System.Net.Sockets.NetworkStream.CanRead%2A> and <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> properties of the <xref:System.Net.Sockets.NetworkStream>. If you specify <xref:System.IO.FileAccess>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method. If you specify <xref:System.IO.FileAccess>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method. If you specify <xref:System.IO.FileAccess>, both method calls are allowed.  
  
   
  
## Examples  
 The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  
  
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]
 [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
 -or-  
  
 the &lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt; property of the <paramref name="socket" /> parameter is not &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.  
  
 -or-  
  
 the <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="socket">The &lt;xref:System.Net.Sockets.Socket&gt; that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data.</param>
        <param name="access">A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specifies the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided &lt;xref:System.Net.Sockets.Socket&gt;.</param>
        <param name="ownsSocket">Set to <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the &lt;xref:System.Net.Sockets.Socket&gt;; otherwise, <see langword="false" />.</param>
        <summary>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified &lt;xref:System.Net.Sockets.Socket&gt; with the specified access rights and the specified &lt;xref:System.Net.Sockets.Socket&gt; ownership.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Net.Sockets.NetworkStream> is created with read/write access to the specified <xref:System.Net.Sockets.Socket>. If the value of the `ownsSocket` parameter is `true`, the <xref:System.Net.Sockets.NetworkStream> takes ownership of the underlying <xref:System.Net.Sockets.Socket>, and calling the <xref:System.Net.Sockets.NetworkStream.Close%2A> method also closes the underlying <xref:System.Net.Sockets.Socket>.  
  
 The `access` parameter sets the <xref:System.Net.Sockets.NetworkStream.CanRead%2A> and <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> properties of the <xref:System.Net.Sockets.NetworkStream>. If you specify <xref:System.IO.FileAccess>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method. If you specify <xref:System.IO.FileAccess>, then the <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method. If you specify <xref:System.IO.FileAccess>, both method calls are allowed.  
  
   
  
## Examples  
 The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  
  
 [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]
 [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]
 [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="socket" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The <paramref name="socket" /> parameter is not connected.  
  
 -or-  
  
 The &lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt; property of the <paramref name="socket" /> parameter is not &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.  
  
 -or-  
  
 The <paramref name="socket" /> parameter is in a nonblocking state.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type &lt;xref:System.Byte&gt; that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in `buffer` to begin storing the data.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">The &lt;xref:System.AsyncCallback&gt; delegate that is executed when BeginRead completes.</param>
        <param name="state">An object that contains any additional user-defined data.</param>
        <summary>Begins an asynchronous read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous call.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The BeginRead method starts asynchronously reading data from the incoming network buffers. Calling the BeginRead method gives you the ability to receive data within a separate execution thread.  
  
 You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the BeginRead method. At the very minimum, your `state` parameter must contain the <xref:System.Net.Sockets.NetworkStream>. Because you will want to obtain the received data within your callback method, you should create a small class or structure to hold a read buffer and any other useful information. Pass the structure or class instance to the BeginRead method through the `state` parameter.  
  
 Your callback method should call the <xref:System.Net.Sockets.NetworkStream.EndRead%2A> method. When your application calls BeginRead, the system will wait until data is received or an error occurs, and then the system will use a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.NetworkStream.EndRead%2A> until the provided <xref:System.Net.Sockets.NetworkStream> reads data or throws an exception. If you want the original thread to block after you call the BeginRead method, use the <xref:System.Threading.WaitHandle.WaitOne%2A> method. Call <xref:System.Threading.EventWaitHandle.Set%2A> in the callback method when you want the original thread to continue executing. For additional information about writing callback methods, see [Marshaling a Delegate as a Callback Method](~/add/includes/ajax-current-ext-md.md).  
  
 The BeginRead method reads as much data as is available, up to the number of bytes specified by the `size` parameter.  
  
> [!NOTE]
>  If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>. If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
 Read and write operations can be performed simultaneously on an instance of the <xref:System.Net.Sockets.NetworkStream> class without the need for synchronization. As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required.  
  
   
  
## Examples  
 The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  
  
 [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]
 [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]
 [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="offset" /> parameter is greater than the length of the <paramref name="buffer" /> paramater.  
  
 -or-  
  
 The <paramref name="size" /> is less than 0.  
  
 -or-  
  
 The <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">The underlying &lt;xref:System.Net.Sockets.Socket&gt; is closed.  
  
 -or-  
  
 There was a failure while reading from the network.  
  
 -or-  
  
 An error occurred when accessing the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type &lt;xref:System.Byte&gt; that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in `buffer` to begin sending the data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="callback">The &lt;xref:System.AsyncCallback&gt; delegate that is executed when BeginWrite completes.</param>
        <param name="state">An object that contains any additional user-defined data.</param>
        <summary>Begins an asynchronous write to a stream.</summary>
        <returns>An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous call.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The BeginWrite method starts an asynchronous send operation to the remote host. Calling the BeginWrite method gives you the ability to send data within a separate execution thread.  
  
 You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the BeginWrite method. At the very minimum, your `state` parameter must contain the <xref:System.Net.Sockets.NetworkStream>. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.NetworkStream> and the other required information. Pass the structure or class instance to the BeginWrite method through the `state` parameter.  
  
 Your callback method should implement the <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> method. When your application calls BeginWrite, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.NetworkStream.EndWrite%2A> until the <xref:System.Net.Sockets.NetworkStream> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the BeginWrite method, use the <xref:System.Threading.WaitHandle.WaitOne%2A> method. Call <xref:System.Threading.EventWaitHandle.Set%2A> in the callback method when you want the original thread to continue executing. For additional information about writing callback methods, see [Marshaling a Delegate as a Callback Method](~/add/includes/ajax-current-ext-md.md).  
  
> [!NOTE]
>  If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>. If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
 Read and write operations can be performed simultaneously on an instance of the <xref:System.Net.Sockets.NetworkStream> class without the need for synchronization. As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required.  
  
   
  
## Examples  
 The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  
  
 [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]
 [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]
 [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  
  
 -or-  
  
 The <paramref name="size" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">The underlying &lt;xref:System.Net.Sockets.Socket&gt; is closed.  
  
 -or-  
  
 There was a failure while writing to the network.  
  
 -or-  
  
 An error occurred when accessing the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports reading.</summary>
        <value>
          <see langword="true" /> if data can be read from the stream; otherwise, <see langword="false" />. The default value is <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If CanRead is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method. Provide the appropriate <xref:System.IO.FileAccess> enumerated value in the constructor to set the readability and writability of the <xref:System.Net.Sockets.NetworkStream>. The CanRead property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.  
  
   
  
## Examples  
 The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the stream supports seeking. This property is not currently supported.This property always returns <see langword="false" />.</summary>
        <value>
          <see langword="false" /> in all cases to indicate that <see cref="T:System.Net.Sockets.NetworkStream" /> cannot seek a specific location in the stream.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether timeout properties are usable for <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <value>
          <see langword="true" /> in all cases.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property is present because it is inherited from <xref:System.IO.Stream>.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports writing.</summary>
        <value>
          <see langword="true" /> if data can be written to the <see cref="T:System.Net.Sockets.NetworkStream" />; otherwise, <see langword="false" />. The default value is <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If CanWrite is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method. Provide the appropriate <xref:System.IO.FileAccess> enumerated value in the constructor to set the readability and writability of the <xref:System.Net.Sockets.NetworkStream>. The CanWrite property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.  
  
   
  
## Examples  
 The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">A 32-bit signed integer that specifies the number of milliseconds to wait to send any remaining data before closing.</param>
        <summary>Closes the <see cref="T:System.Net.Sockets.NetworkStream" /> after waiting the specified time to allow data to be sent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Close method frees both unmanaged and managed resources associated with the <xref:System.Net.Sockets.NetworkStream>. If the <xref:System.Net.Sockets.NetworkStream> owns the underlying <xref:System.Net.Sockets.Socket>, it is closed as well.  
  
 If a <xref:System.Net.Sockets.NetworkStream> was associated with a <xref:System.Net.Sockets.TcpClient>, the Close method will close the TCP connection, but not dispose of the associated <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="timeout" /> parameter is less than -1.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether data is available on the <see cref="T:System.Net.Sockets.NetworkStream" /> to be read.</summary>
        <value>
          <see langword="true" /> if data is available on the stream to be read; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use the DataAvailable property to determine if data is ready to be read. If DataAvailable is `true`, a call to <xref:System.Net.Sockets.NetworkStream.Read%2A> returns immediately. If the remote host shuts down or closes the connection, DataAvailable may throw a <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <exception cref="T:System.IO.IOException">The underlying &lt;xref:System.Net.Sockets.Socket&gt; is closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Use the &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.NetworkStream" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is called by the public `Dispose` method and the <xref:System.Object.Finalize%2A> method. `Dispose` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.  
  
 When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.NetworkStream> references. This method invokes the `Dispose` method of each referenced object.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An &lt;xref:System.IAsyncResult&gt; that represents an asynchronous call.</param>
        <summary>Handles the end of an asynchronous read.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The EndRead method completes the asynchronous read operation started in the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.  
  
 Before calling <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned from the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method as a parameter.  
  
 Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method. Extract the receiving <xref:System.Net.Sockets.NetworkStream> from this state object. After obtaining the <xref:System.Net.Sockets.NetworkStream>, call the EndRead method to successfully complete the read operation and return the number of bytes read.  
  
 The EndRead method blocks until data is available. The EndRead method reads as much data as is available up to the number of bytes specified in the `size` parameter of the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection and all available data has been received, the EndRead method completes immediately and returns zero bytes.  
  
 To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.  
  
> [!NOTE]
>  If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>. If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
   
  
## Examples  
 In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  
  
 [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]
 [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]
 [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The underlying &lt;xref:System.Net.Sockets.Socket&gt; is closed.  
  
 -or-  
  
 An error occurred when accessing the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The &lt;xref:System.IAsyncResult&gt; that represents the asynchronous call.</param>
        <summary>Handles the end of an asynchronous write.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 EndWrite completes the asynchronous send operation started in <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 Before calling <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned from the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method as a parameter.  
  
 Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> property of the `IAsyncResult` parameter to obtain the <xref:System.Net.Sockets.NetworkStream>. After obtaining the <xref:System.Net.Sockets.NetworkStream>, you can call the EndWrite method to successfully complete the send operation and return the number of bytes sent.  
  
 The EndWrite method blocks until the requested number of bytes are sent.  
  
> [!NOTE]
>  If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>. If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
   
  
## Examples  
 In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  
  
 [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]
 [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]
 [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The underlying &lt;xref:System.Net.Sockets.Socket&gt; is closed.  
  
 -or-  
  
 An error occurred while writing to the network.  
  
 -or-  
  
 An error occurred when accessing the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method overrides <xref:System.Object.Finalize%2A?displayProperty=fullName>. Application code should not call this method; an object's <xref:System.Object.Finalize%2A> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  
  
 For more information about using the Finalize method, see [Finalize Methods and Destructors](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/add/includes/ajax-current-ext-md.md), and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Flushes data from the stream. This method is reserved for future use.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Flush method implements the <xref:System.IO.Stream.Flush%2A?displayProperty=fullName> method; however, because <xref:System.Net.Sockets.NetworkStream> is not buffered, it has no affect on network streams. Calling the Flush method does not throw an exception.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">A cancellation token used to propagate notification that this  operation should be canceled.</param>
        <summary>Flushes data from the stream as an asynchronous operation.</summary>
        <returns>Returns &lt;xref:System.Threading.Tasks.Task&gt;.  
  
 The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This operation will not block. The returned <xref:System.Threading.Tasks.Task> object will complete after data has been flushed from the stream for the <xref:System.Net.Sockets.NetworkStream> instance.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of the data available on the stream. This property is not currently supported and always throws a &lt;xref:System.NotSupportedException&gt;.</summary>
        <value>The length of the data available on the stream.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position in the stream. This property is not currently supported and always throws a &lt;xref:System.NotSupportedException&gt;.</summary>
        <value>The current position in the stream.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type &lt;xref:System.Byte&gt; that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in `buffer` to begin storing the data to.</param>
        <param name="size">The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <returns>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method reads data into the `buffer` parameter and returns the number of bytes successfully read. If no data is available for reading, the Read method returns 0. The Read operation reads as much data as is available, up to the number of bytes specified by the `size` parameter. If the remote host shuts down the connection, and all available data has been received, the Read method completes immediately and return zero bytes.  
  
> [!NOTE]
>  Check to see if the <xref:System.Net.Sockets.NetworkStream> is readable by calling the <xref:System.Net.Sockets.NetworkStream.CanRead%2A> property. If you attempt to read from a <xref:System.Net.Sockets.NetworkStream> that is not readable, you will get an <xref:System.IO.IOException>.  
  
> [!NOTE]
>  If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>. If so, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
   
  
## Examples  
 The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  
  
 -or-  
  
 The <paramref name="size" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.  
  
 -or-  
  
 An error occurred when accessing the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.IO.IOException">The underlying &lt;xref:System.Net.Sockets.Socket&gt; is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.  
  
 -or-  
  
 There is a failure reading from the network.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read.</summary>
        <value>
          <see langword="true" /> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read; otherwise, <see langword="false" />. The default value is <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You must derive from the <xref:System.Net.Sockets.NetworkStream> class to use the Readable property. If Readable is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Read%2A> method. You can also determine whether a <xref:System.Net.Sockets.NetworkStream> is readable by checking the publicly accessible <xref:System.Net.Sockets.NetworkStream.CanRead%2A> property.  
  
 The Readable property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.  
  
   
  
## Examples  
 In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]
 [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]
 [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time that a read operation blocks waiting for data.</summary>
        <value>A &lt;xref:System.Int32&gt; that specifies the amount of time, in milliseconds, that will elapse before a read operation fails. The default value, &lt;xref:System.Threading.Timeout.Infinite&gt;, specifies that the read operation does not time out.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the read operation does not complete within the time specified by this property, the read operation throws an <xref:System.IO.IOException>.  
  
> [!NOTE]
>  This property affects only synchronous reads performed by calling the <xref:System.Net.Sockets.NetworkStream.Read%2A> method. This property does not affect asynchronous reads performed by calling the <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> method.  
  
   
  
## Examples  
 The following code example sets the read time-out for a network stream to 10 milliseconds.  
  
 [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than or equal to zero and is not &lt;xref:System.Threading.Timeout.Infinite&gt;.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">This parameter is not used.</param>
        <param name="origin">This parameter is not used.</param>
        <summary>Sets the current position of the stream to the given value. This method is not currently supported and always throws a &lt;xref:System.NotSupportedException&gt;.</summary>
        <returns>The position in the stream.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">This parameter is not used.</param>
        <summary>Sets the length of the stream. This method always throws a &lt;xref:System.NotSupportedException&gt;.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Any use of this property.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the underlying &lt;xref:System.Net.Sockets.Socket&gt;.</summary>
        <value>A &lt;xref:System.Net.Sockets.Socket&gt; that represents the underlying network connection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes deriving from <xref:System.Net.Sockets.NetworkStream> can use this property to get the underlying <xref:System.Net.Sockets.Socket>. Use the underlying <xref:System.Net.Sockets.Socket> returned from the Socket property if you require access beyond that which <xref:System.Net.Sockets.NetworkStream> provides.  
  
> [!NOTE]
>  This property is accessible only through this class or a derived class.  
  
   
  
## Examples  
 The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]
 [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]
 [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type &lt;xref:System.Byte&gt; that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <param name="offset">The location in `buffer` from which to start writing data.</param>
        <param name="size">The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />.</param>
        <summary>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Write method starts at the specified `offset` and sends `size` bytes from the contents of `buffer` to the network. The Write method blocks until the requested number of bytes is sent or a <xref:System.Net.Sockets.SocketException> is thrown. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
> [!NOTE]
>  Check to see if the <xref:System.Net.Sockets.NetworkStream> is writable by accessing the <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> property. If you attempt to write to a <xref:System.Net.Sockets.NetworkStream> that is not writable, you will get an <xref:System.IO.IOException>. If you receive an <xref:System.IO.IOException>, check the <xref:System.Exception.InnerException%2A> property to determine if it was caused by a <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  
  
 [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]
 [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]
 [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="offset" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="offset" /> parameter is greater than the length of <paramref name="buffer" />.  
  
 -or-  
  
 The <paramref name="size" /> parameter is less than 0.  
  
 -or-  
  
 The <paramref name="size" /> parameter is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.IO.IOException">There was a failure while writing to the network.  
  
 -or-  
  
 An error occurred when accessing the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.NetworkStream" /> is closed.  
  
 -or-  
  
 There was a failure reading from the network.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> is writable.</summary>
        <value>
          <see langword="true" /> if data can be written to the stream; otherwise, <see langword="false" />. The default value is <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You must derive from the <xref:System.Net.Sockets.NetworkStream> class to use the Writeable property. If Writeable is `true`, <xref:System.Net.Sockets.NetworkStream> allows calls to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method. You can also determine whether a <xref:System.Net.Sockets.NetworkStream> is writable by checking the publicly accessible <xref:System.Net.Sockets.NetworkStream.CanWrite%2A> property.  
  
 The Writeable property is set when the <xref:System.Net.Sockets.NetworkStream> is initialized.  
  
   
  
## Examples  
 In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  
  
 [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]
 [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]
 [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time that a write operation blocks waiting for data.</summary>
        <value>A &lt;xref:System.Int32&gt; that specifies the amount of time, in milliseconds, that will elapse before a write operation fails. The default value, &lt;xref:System.Threading.Timeout.Infinite&gt;, specifies that the write operation does not time out.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the write operation does not complete within the time specified by this property, the write operation throws a <xref:System.IO.IOException>.  
  
> [!NOTE]
>  This property affects only synchronous write operations performed by calling the <xref:System.Net.Sockets.NetworkStream.Write%2A> method. This property does not affect asynchronous writes performed by calling the <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> method.  
  
   
  
## Examples  
 The following code example sets the write time-out for a network stream to 10 milliseconds.  
  
 [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]
 [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than or equal to zero and is not &lt;xref:System.Threading.Timeout.Infinite&gt;.</exception>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>